<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atharva – Business Case Studies | Arohanagara</title>
    <link rel="stylesheet" href="style.css">

    <style>
        /* Extra styling just for this page */
        .bcs-hero {
            height: 45vh;
            background: linear-gradient(135deg, #3B4252, #434C5E);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
        }

        .bcs-title {
            font-size: 3rem;
            font-weight: 800;
            color: #D8DEE9;
        }

        .bcs-domain {
            font-size: 1.2rem;
            margin-top: 8px;
            color: #88C0D0;
        }

        .bcs-author {
            font-size: 0.95rem;
            margin-top: 6px;
            opacity: 0.7;
            color: #EBCB8B;
        }

        /* Readability upgrades */
        .case-text {
            margin-bottom: 22px;
            line-height: 1.6;
        }

        .case-heading {
            display: block;
            margin-top: 28px;
            margin-bottom: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            color: #EBCB8B;
        }

        .case-section {
            margin-top: 8px;
            margin-bottom: 30px;
            margin-left: 20px;
            line-height: 1.55;
        }

        /* Animation classes */
        .fade-up {
            opacity: 0;
            transform: translateY(25px);
            transition: all 0.8s ease;
        }

        .fade-up.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .delay-1 {
            transition-delay: 0.25s;
        }

        .delay-2 {
            transition-delay: 0.45s;
        }
    </style>
</head>

<body>

    <!-- NAVBAR -->
    <nav class="navbar">
        <div class="logo">Arohanagara</div>
        <ul class="nav-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#city-info">City Info</a></li>
            <li><a href="index.html#layout">Layout</a></li>
            <li><a href="index.html#budget">Budget</a></li>
            <li><a href="index.html#revenue">Revenue</a></li>
            <li><a href="index.html#team">Team</a></li>
            <li><a href="athbcs.html" class="active">Atharva</a></li>
        </ul>
    </nav>

    <!-- HERO HEADER -->
    <section class="bcs-hero">
        <div>
            <h1 class="bcs-title fade-up">Business Use-Case Analysis</h1>
            <p class="bcs-domain fade-up delay-1">Domain: Technology, Data Systems & Smart City Operations</p>
            <p class="bcs-author fade-up delay-2">Prepared by Atharva · USN 264</p>
        </div>
    </section>

    <!-- CONTENT -->
    <section class="page-section">

        <h2>Business Case Applications Identified by Atharva</h2>

        <!-- CASE STUDY 1 -->
        <div class="content-card fade-up">
            <h3>1. Real-Time Disaster Alerting from City-wide Sensor Networks</h3>

            <p class="case-text">
                Aroha Nagar deploys a large network of environmental poles that continuously
                capture factors like wind speed, humidity, air pressure, temperature, and even
                light exposure. These are converted into compact character streams that grow
                extremely long over time. Certain combinations within these sequences
                correspond to dangerous weather patterns or early signs of infrastructure stress.
                Detecting these patterns quickly is essential for automated alerting and emergency
                readiness.
            </p>

            <p class="case-text">
                Manually scanning each character in such massive streams is impractical.
                Since dangerous signatures appear rarely, the ideal strategy is to “skip ahead”
                through safe segments rather than check every window sequentially.
            </p>

            <span class="case-heading">Algorithm Used – Boyer–Moore Pattern Searching</span>

            <p class="case-text">
                Boyer–Moore excels in scenarios where rare patterns must be found inside extremely
                long strings. Instead of verifying every character, it compares from right to left
                and jumps forward using the bad-character and good-suffix heuristics. This
                significantly cuts down unnecessary comparisons.
            </p>

            <span class="case-heading">Efficiency & Optimizations</span>

            <ul class="case-section">
                <li>Worst-case: O(n + m), but real usage is much faster due to skipping.</li>
                <li>Works well on low-power sensor devices.</li>
                <li>Preprocessing once allows repeated fast scanning.</li>
                <li>Scales as the number of sensors increases.</li>
            </ul>
        </div>

        <!-- CASE STUDY 2 -->
        <div class="content-card fade-up">
            <h3>2. Skill-Matching System for Students, Workers, and Startups</h3>

            <p class="case-text">
                Aroha Nagar has a growing community of students, freelancers, and startups actively
                upgrading digital skills. Training centers maintain databases with thousands of
                skills and job requirements. Users often search with incomplete words like “jav”
                or “pyth”, expecting instant and relevant suggestions.
            </p>

            <span class="case-heading">Data Structure Used – Trie</span>

            <p class="case-text">
                A Trie stores words as character paths, allowing extremely fast prefix-based
                lookups. Because search time depends only on the length of the input word, not
                the number of stored words, it remains efficient as the database expands.
            </p>

            <span class="case-heading">Efficiency & Optimizations</span>

            <ul class="case-section">
                <li>Search & Insert: O(k)</li>
                <li>Perfect for autocomplete features.</li>
                <li>Path compression reduces memory usage.</li>
            </ul>
        </div>

        <!-- CASE STUDY 3 -->
        <div class="content-card fade-up">
            <h3>3. IT Asset Lifecycle & E-Waste Routing</h3>

            <p class="case-text">
                The city’s repair centers and refurbishing units handle large volumes of devices,
                each with known expiry or end-of-life dates. Efficient e-waste management requires
                processing devices approaching expiry first.
            </p>

            <span class="case-heading">Data Structure Used – Binary Search Tree</span>

            <p class="case-text">
                A BST organizes devices by expiry date, giving instant access to the earliest
                expiring items through its leftmost node. This structure is simple yet powerful
                for lifecycle ordering.
            </p>

            <span class="case-heading">Efficiency & Optimizations</span>

            <ul class="case-section">
                <li>Search/Insert/Delete: O(log n) average</li>
                <li>Balanced BSTs maintain efficiency long-term</li>
                <li>Supports range queries: expiry within N days</li>
            </ul>
        </div>

        <!-- CASE STUDY 4 -->
        <div class="content-card fade-up">
            <h3>4. Traffic Classification Using Drone & Roadside Counter Data</h3>

            <p class="case-text">
                Drone images and counter readings generate batches of traffic density data.
                Instead of requiring a perfect sort, the goal is to classify readings into low,
                medium, and high congestion levels.
            </p>

            <span class="case-heading">Algorithm Used – Quick Sort</span>

            <p class="case-text">
                Quick Sort’s partitioning mechanism instantly groups values, enabling congestion
                levels to be detected even before full sorting completes.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Average: O(n log n)</li>
                <li>Median/random pivot avoids worst cases</li>
                <li>In-place sorting requires minimal memory</li>
            </ul>
        </div>

        <!-- CASE STUDY 5 -->
        <div class="content-card fade-up">
            <h3>5. Monitoring Usage Patterns in Public Wi-Fi Networks</h3>

            <p class="case-text">
                Public Wi-Fi hotspots update logs continuously—tracking usage, failed logins,
                bandwidth peaks, and anomalies. The system needs fast updates and fast range
                queries for real-time monitoring.
            </p>

            <span class="case-heading">Data Structure Used – Fenwick Tree (BIT)</span>

            <p class="case-text">
                A Fenwick Tree supports prefix sums and updates in logarithmic time, making
                it ideal for tracking time-based activity metrics.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Update: O(log n)</li>
                <li>Query: O(log n)</li>
                <li>Lower memory than Segment Tree</li>
            </ul>
        </div>

        <!-- CASE STUDY 6 -->
        <div class="content-card fade-up">
            <h3>6. Scheduling Compute Resources for Local Data Centres</h3>

            <p class="case-text">
                Shared server clusters must minimize communication delay between nodes.
                The network of servers forms a weighted graph where edges represent latency.
            </p>

            <span class="case-heading">Algorithm Used – Kruskal’s Algorithm</span>

            <p class="case-text">
                Kruskal finds a minimum spanning tree that ensures efficient connectivity,
                reducing overall communication cost across compute clusters.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Sorting edges: O(E log V)</li>
                <li>Union-Find makes merges extremely fast</li>
            </ul>
        </div>

        <!-- CASE STUDY 7 -->
        <div class="content-card fade-up">
            <h3>7. Managing Student Records in Digital Classrooms</h3>

            <p class="case-text">
                Digital learning centers store attendance, quizzes, assignments, and profiles.
                Accessing a student record must be instant.
            </p>

            <span class="case-heading">Data Structure Used – Hash Table</span>

            <p class="case-text">
                Hash tables map student IDs directly to their records, avoiding linear or
                tree-based searches.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Lookup: O(1) average</li>
                <li>Good hashing minimizes collisions</li>
                <li>Dynamic resizing keeps speed consistent</li>
            </ul>
        </div>

        <!-- CASE STUDY 8 -->
        <div class="content-card fade-up">
            <h3>8. Routing Stock Between Warehouses & Retail Units</h3>

            <p class="case-text">
                Distribution centers must frequently compute the cheapest route between
                numerous warehouses and retail nodes.
            </p>

            <span class="case-heading">Algorithm Used – Floyd–Warshall</span>

            <p class="case-text">
                Floyd–Warshall computes all-pairs shortest paths, allowing instant answers
                to logistics decisions once preprocessing is complete.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Time: O(n³)</li>
                <li>Space: O(n²)</li>
                <li>Ideal for medium-sized fixed road networks</li>
            </ul>
        </div>

        <!-- CASE STUDY 9 -->
        <div class="content-card fade-up">
            <h3>9. Maintenance Route Planning for Smart City Infrastructure</h3>

            <p class="case-text">
                Technicians must travel optimally to malfunctioning kiosks, charging points,
                and IoT nodes across the city.
            </p>

            <span class="case-heading">Algorithm Used – Dijkstra’s Algorithm</span>

            <p class="case-text">
                Dijkstra efficiently finds the shortest paths when all road weights are
                non-negative—perfect for real-world city maps.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Using min-heap: O(E log V)</li>
                <li>Scales well as devices and roads increase</li>
            </ul>
        </div>

        <!-- CASE STUDY 10 -->
        <div class="content-card fade-up">
            <h3>10. Detecting Repeated or Fraudulent Patterns in Micro-Loan Applications</h3>

            <p class="case-text">
                Financial centers often detect suspicious repetition in loan applications.
                A fast pattern-identification system prevents fraud and duplicate entries.
            </p>

            <span class="case-heading">Algorithm Used – Rabin–Karp</span>

            <p class="case-text">
                Rabin–Karp uses rolling hashes for substring comparison, avoiding
                character-by-character checking and enabling fast detection.
            </p>

            <span class="case-heading">Efficiency</span>

            <ul class="case-section">
                <li>Typical time: O(n + m)</li>
                <li>Rolling hash avoids recomputation</li>
                <li>Large modulus reduces collisions</li>
            </ul>
        </div>

    </section>

    <footer>
        <p>© 2025 Arohanagara Project | Atharva’s Case Study Page</p>
    </footer>

    <!-- JS FOR FADE-UP ANIMATIONS -->
    <script>
        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add("visible");
                    }
                });
            },
            { threshold: 0.2 }
        );

        document.querySelectorAll(".fade-up").forEach((el) => observer.observe(el));
    </script>

</body>
</html>
